// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osmand_index.proto

#ifndef PROTOBUF_osmand_5findex_2eproto__INCLUDED
#define PROTOBUF_osmand_5findex_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace OsmAnd {
namespace OBF {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_osmand_5findex_2eproto();
void protobuf_AssignDesc_osmand_5findex_2eproto();
void protobuf_ShutdownFile_osmand_5findex_2eproto();

class OsmAndStoredIndex;
class FileIndex;
class AddressPart;
class CityBlock;
class PoiPart;
class MapLevel;
class MapPart;
class RoutingSubregion;
class RoutingPart;
class HHRoutingPart;
class TransportPart;

// ===================================================================

class OsmAndStoredIndex : public ::google::protobuf::MessageLite {
 public:
  OsmAndStoredIndex();
  virtual ~OsmAndStoredIndex();

  OsmAndStoredIndex(const OsmAndStoredIndex& from);

  inline OsmAndStoredIndex& operator=(const OsmAndStoredIndex& from) {
    CopyFrom(from);
    return *this;
  }

  static const OsmAndStoredIndex& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OsmAndStoredIndex* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OsmAndStoredIndex* other);

  // implements Message ----------------------------------------------

  OsmAndStoredIndex* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OsmAndStoredIndex& from);
  void MergeFrom(const OsmAndStoredIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required int64 dateCreated = 18;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 18;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);

  // repeated .OsmAnd.OBF.FileIndex fileIndex = 7;
  inline int fileindex_size() const;
  inline void clear_fileindex();
  static const int kFileIndexFieldNumber = 7;
  inline const ::OsmAnd::OBF::FileIndex& fileindex(int index) const;
  inline ::OsmAnd::OBF::FileIndex* mutable_fileindex(int index);
  inline ::OsmAnd::OBF::FileIndex* add_fileindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::FileIndex >&
      fileindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::FileIndex >*
      mutable_fileindex();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndStoredIndex)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();

  ::google::protobuf::int64 datecreated_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::FileIndex > fileindex_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static OsmAndStoredIndex* default_instance_;
};
// -------------------------------------------------------------------

class FileIndex : public ::google::protobuf::MessageLite {
 public:
  FileIndex();
  virtual ~FileIndex();

  FileIndex(const FileIndex& from);

  inline FileIndex& operator=(const FileIndex& from) {
    CopyFrom(from);
    return *this;
  }

  static const FileIndex& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileIndex* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileIndex* other);

  // implements Message ----------------------------------------------

  FileIndex* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileIndex& from);
  void MergeFrom(const FileIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 dateModified = 2;
  inline bool has_datemodified() const;
  inline void clear_datemodified();
  static const int kDateModifiedFieldNumber = 2;
  inline ::google::protobuf::int64 datemodified() const;
  inline void set_datemodified(::google::protobuf::int64 value);

  // required string fileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required int32 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // repeated .OsmAnd.OBF.AddressPart addressIndex = 8;
  inline int addressindex_size() const;
  inline void clear_addressindex();
  static const int kAddressIndexFieldNumber = 8;
  inline const ::OsmAnd::OBF::AddressPart& addressindex(int index) const;
  inline ::OsmAnd::OBF::AddressPart* mutable_addressindex(int index);
  inline ::OsmAnd::OBF::AddressPart* add_addressindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressPart >&
      addressindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressPart >*
      mutable_addressindex();

  // repeated .OsmAnd.OBF.TransportPart transportIndex = 9;
  inline int transportindex_size() const;
  inline void clear_transportindex();
  static const int kTransportIndexFieldNumber = 9;
  inline const ::OsmAnd::OBF::TransportPart& transportindex(int index) const;
  inline ::OsmAnd::OBF::TransportPart* mutable_transportindex(int index);
  inline ::OsmAnd::OBF::TransportPart* add_transportindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportPart >&
      transportindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportPart >*
      mutable_transportindex();

  // repeated .OsmAnd.OBF.PoiPart poiIndex = 10;
  inline int poiindex_size() const;
  inline void clear_poiindex();
  static const int kPoiIndexFieldNumber = 10;
  inline const ::OsmAnd::OBF::PoiPart& poiindex(int index) const;
  inline ::OsmAnd::OBF::PoiPart* mutable_poiindex(int index);
  inline ::OsmAnd::OBF::PoiPart* add_poiindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::PoiPart >&
      poiindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::PoiPart >*
      mutable_poiindex();

  // repeated .OsmAnd.OBF.MapPart mapIndex = 11;
  inline int mapindex_size() const;
  inline void clear_mapindex();
  static const int kMapIndexFieldNumber = 11;
  inline const ::OsmAnd::OBF::MapPart& mapindex(int index) const;
  inline ::OsmAnd::OBF::MapPart* mutable_mapindex(int index);
  inline ::OsmAnd::OBF::MapPart* add_mapindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapPart >&
      mapindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapPart >*
      mutable_mapindex();

  // repeated .OsmAnd.OBF.RoutingPart routingIndex = 12;
  inline int routingindex_size() const;
  inline void clear_routingindex();
  static const int kRoutingIndexFieldNumber = 12;
  inline const ::OsmAnd::OBF::RoutingPart& routingindex(int index) const;
  inline ::OsmAnd::OBF::RoutingPart* mutable_routingindex(int index);
  inline ::OsmAnd::OBF::RoutingPart* add_routingindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingPart >&
      routingindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingPart >*
      mutable_routingindex();

  // repeated .OsmAnd.OBF.HHRoutingPart hhRoutingIndex = 13;
  inline int hhroutingindex_size() const;
  inline void clear_hhroutingindex();
  static const int kHhRoutingIndexFieldNumber = 13;
  inline const ::OsmAnd::OBF::HHRoutingPart& hhroutingindex(int index) const;
  inline ::OsmAnd::OBF::HHRoutingPart* mutable_hhroutingindex(int index);
  inline ::OsmAnd::OBF::HHRoutingPart* add_hhroutingindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::HHRoutingPart >&
      hhroutingindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::HHRoutingPart >*
      mutable_hhroutingindex();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.FileIndex)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_datemodified();
  inline void clear_has_datemodified();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 datemodified_;
  ::std::string* filename_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressPart > addressindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportPart > transportindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::PoiPart > poiindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapPart > mapindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingPart > routingindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::HHRoutingPart > hhroutingindex_;
  ::google::protobuf::int32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static FileIndex* default_instance_;
};
// -------------------------------------------------------------------

class AddressPart : public ::google::protobuf::MessageLite {
 public:
  AddressPart();
  virtual ~AddressPart();

  AddressPart(const AddressPart& from);

  inline AddressPart& operator=(const AddressPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddressPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddressPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddressPart* other);

  // implements Message ----------------------------------------------

  AddressPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddressPart& from);
  void MergeFrom(const AddressPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string nameEn = 4;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 4;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  inline ::std::string* release_nameen();
  inline void set_allocated_nameen(::std::string* nameen);

  // optional int64 indexNameOffset = 5;
  inline bool has_indexnameoffset() const;
  inline void clear_indexnameoffset();
  static const int kIndexNameOffsetFieldNumber = 5;
  inline ::google::protobuf::int64 indexnameoffset() const;
  inline void set_indexnameoffset(::google::protobuf::int64 value);

  // repeated .OsmAnd.OBF.CityBlock cities = 8;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 8;
  inline const ::OsmAnd::OBF::CityBlock& cities(int index) const;
  inline ::OsmAnd::OBF::CityBlock* mutable_cities(int index);
  inline ::OsmAnd::OBF::CityBlock* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlock >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlock >*
      mutable_cities();

  // repeated string additionalTags = 9;
  inline int additionaltags_size() const;
  inline void clear_additionaltags();
  static const int kAdditionalTagsFieldNumber = 9;
  inline const ::std::string& additionaltags(int index) const;
  inline ::std::string* mutable_additionaltags(int index);
  inline void set_additionaltags(int index, const ::std::string& value);
  inline void set_additionaltags(int index, const char* value);
  inline void set_additionaltags(int index, const char* value, size_t size);
  inline ::std::string* add_additionaltags();
  inline void add_additionaltags(const ::std::string& value);
  inline void add_additionaltags(const char* value);
  inline void add_additionaltags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& additionaltags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_additionaltags();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.AddressPart)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nameen();
  inline void clear_has_nameen();
  inline void set_has_indexnameoffset();
  inline void clear_has_indexnameoffset();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::std::string* name_;
  ::std::string* nameen_;
  ::google::protobuf::int64 indexnameoffset_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlock > cities_;
  ::google::protobuf::RepeatedPtrField< ::std::string> additionaltags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static AddressPart* default_instance_;
};
// -------------------------------------------------------------------

class CityBlock : public ::google::protobuf::MessageLite {
 public:
  CityBlock();
  virtual ~CityBlock();

  CityBlock(const CityBlock& from);

  inline CityBlock& operator=(const CityBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const CityBlock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CityBlock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CityBlock* other);

  // implements Message ----------------------------------------------

  CityBlock* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CityBlock& from);
  void MergeFrom(const CityBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.CityBlock)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static CityBlock* default_instance_;
};
// -------------------------------------------------------------------

class PoiPart : public ::google::protobuf::MessageLite {
 public:
  PoiPart();
  virtual ~PoiPart();

  PoiPart(const PoiPart& from);

  inline PoiPart& operator=(const PoiPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const PoiPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PoiPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PoiPart* other);

  // implements Message ----------------------------------------------

  PoiPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PoiPart& from);
  void MergeFrom(const PoiPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 left = 4;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 4;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 right = 5;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 5;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 top = 6;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 6;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 bottom = 7;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 7;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.PoiPart)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::std::string* name_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static PoiPart* default_instance_;
};
// -------------------------------------------------------------------

class MapLevel : public ::google::protobuf::MessageLite {
 public:
  MapLevel();
  virtual ~MapLevel();

  MapLevel(const MapLevel& from);

  inline MapLevel& operator=(const MapLevel& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapLevel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapLevel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapLevel* other);

  // implements Message ----------------------------------------------

  MapLevel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapLevel& from);
  void MergeFrom(const MapLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // required int32 left = 4;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 4;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 right = 5;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 5;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 top = 6;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 6;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 bottom = 7;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 7;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // optional int32 minzoom = 8;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinzoomFieldNumber = 8;
  inline ::google::protobuf::int32 minzoom() const;
  inline void set_minzoom(::google::protobuf::int32 value);

  // optional int32 maxzoom = 9;
  inline bool has_maxzoom() const;
  inline void clear_maxzoom();
  static const int kMaxzoomFieldNumber = 9;
  inline ::google::protobuf::int32 maxzoom() const;
  inline void set_maxzoom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.MapLevel)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_minzoom();
  inline void clear_has_minzoom();
  inline void set_has_maxzoom();
  inline void clear_has_maxzoom();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::int32 minzoom_;
  ::google::protobuf::int32 maxzoom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static MapLevel* default_instance_;
};
// -------------------------------------------------------------------

class MapPart : public ::google::protobuf::MessageLite {
 public:
  MapPart();
  virtual ~MapPart();

  MapPart(const MapPart& from);

  inline MapPart& operator=(const MapPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapPart* other);

  // implements Message ----------------------------------------------

  MapPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapPart& from);
  void MergeFrom(const MapPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .OsmAnd.OBF.MapLevel levels = 5;
  inline int levels_size() const;
  inline void clear_levels();
  static const int kLevelsFieldNumber = 5;
  inline const ::OsmAnd::OBF::MapLevel& levels(int index) const;
  inline ::OsmAnd::OBF::MapLevel* mutable_levels(int index);
  inline ::OsmAnd::OBF::MapLevel* add_levels();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapLevel >&
      levels() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapLevel >*
      mutable_levels();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.MapPart)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapLevel > levels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static MapPart* default_instance_;
};
// -------------------------------------------------------------------

class RoutingSubregion : public ::google::protobuf::MessageLite {
 public:
  RoutingSubregion();
  virtual ~RoutingSubregion();

  RoutingSubregion(const RoutingSubregion& from);

  inline RoutingSubregion& operator=(const RoutingSubregion& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoutingSubregion& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoutingSubregion* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoutingSubregion* other);

  // implements Message ----------------------------------------------

  RoutingSubregion* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoutingSubregion& from);
  void MergeFrom(const RoutingSubregion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional bool basemap = 3;
  inline bool has_basemap() const;
  inline void clear_basemap();
  static const int kBasemapFieldNumber = 3;
  inline bool basemap() const;
  inline void set_basemap(bool value);

  // required int32 left = 4;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 4;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 right = 5;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 5;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 top = 6;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 6;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 bottom = 7;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 7;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // required int64 shifToData = 8;
  inline bool has_shiftodata() const;
  inline void clear_shiftodata();
  static const int kShifToDataFieldNumber = 8;
  inline ::google::protobuf::int64 shiftodata() const;
  inline void set_shiftodata(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.RoutingSubregion)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_basemap();
  inline void clear_has_basemap();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_shiftodata();
  inline void clear_has_shiftodata();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  bool basemap_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int64 shiftodata_;
  ::google::protobuf::int32 bottom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static RoutingSubregion* default_instance_;
};
// -------------------------------------------------------------------

class RoutingPart : public ::google::protobuf::MessageLite {
 public:
  RoutingPart();
  virtual ~RoutingPart();

  RoutingPart(const RoutingPart& from);

  inline RoutingPart& operator=(const RoutingPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoutingPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoutingPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoutingPart* other);

  // implements Message ----------------------------------------------

  RoutingPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoutingPart& from);
  void MergeFrom(const RoutingPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .OsmAnd.OBF.RoutingSubregion subregions = 5;
  inline int subregions_size() const;
  inline void clear_subregions();
  static const int kSubregionsFieldNumber = 5;
  inline const ::OsmAnd::OBF::RoutingSubregion& subregions(int index) const;
  inline ::OsmAnd::OBF::RoutingSubregion* mutable_subregions(int index);
  inline ::OsmAnd::OBF::RoutingSubregion* add_subregions();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingSubregion >&
      subregions() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingSubregion >*
      mutable_subregions();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.RoutingPart)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingSubregion > subregions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static RoutingPart* default_instance_;
};
// -------------------------------------------------------------------

class HHRoutingPart : public ::google::protobuf::MessageLite {
 public:
  HHRoutingPart();
  virtual ~HHRoutingPart();

  HHRoutingPart(const HHRoutingPart& from);

  inline HHRoutingPart& operator=(const HHRoutingPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const HHRoutingPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HHRoutingPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HHRoutingPart* other);

  // implements Message ----------------------------------------------

  HHRoutingPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HHRoutingPart& from);
  void MergeFrom(const HHRoutingPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // required int64 edition = 3;
  inline bool has_edition() const;
  inline void clear_edition();
  static const int kEditionFieldNumber = 3;
  inline ::google::protobuf::int64 edition() const;
  inline void set_edition(::google::protobuf::int64 value);

  // required string profile = 4;
  inline bool has_profile() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 4;
  inline const ::std::string& profile() const;
  inline void set_profile(const ::std::string& value);
  inline void set_profile(const char* value);
  inline void set_profile(const char* value, size_t size);
  inline ::std::string* mutable_profile();
  inline ::std::string* release_profile();
  inline void set_allocated_profile(::std::string* profile);

  // repeated string profileParams = 5;
  inline int profileparams_size() const;
  inline void clear_profileparams();
  static const int kProfileParamsFieldNumber = 5;
  inline const ::std::string& profileparams(int index) const;
  inline ::std::string* mutable_profileparams(int index);
  inline void set_profileparams(int index, const ::std::string& value);
  inline void set_profileparams(int index, const char* value);
  inline void set_profileparams(int index, const char* value, size_t size);
  inline ::std::string* add_profileparams();
  inline void add_profileparams(const ::std::string& value);
  inline void add_profileparams(const char* value);
  inline void add_profileparams(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& profileparams() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_profileparams();

  // required int64 pointsOffset = 7;
  inline bool has_pointsoffset() const;
  inline void clear_pointsoffset();
  static const int kPointsOffsetFieldNumber = 7;
  inline ::google::protobuf::int64 pointsoffset() const;
  inline void set_pointsoffset(::google::protobuf::int64 value);

  // required int64 pointsLength = 8;
  inline bool has_pointslength() const;
  inline void clear_pointslength();
  static const int kPointsLengthFieldNumber = 8;
  inline ::google::protobuf::int64 pointslength() const;
  inline void set_pointslength(::google::protobuf::int64 value);

  // required int32 left = 9;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 9;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 right = 10;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 10;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 top = 11;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 11;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 bottom = 12;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 12;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.HHRoutingPart)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_edition();
  inline void clear_has_edition();
  inline void set_has_profile();
  inline void clear_has_profile();
  inline void set_has_pointsoffset();
  inline void clear_has_pointsoffset();
  inline void set_has_pointslength();
  inline void clear_has_pointslength();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 edition_;
  ::std::string* profile_;
  ::google::protobuf::RepeatedPtrField< ::std::string> profileparams_;
  ::google::protobuf::int64 pointsoffset_;
  ::google::protobuf::int64 pointslength_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static HHRoutingPart* default_instance_;
};
// -------------------------------------------------------------------

class TransportPart : public ::google::protobuf::MessageLite {
 public:
  TransportPart();
  virtual ~TransportPart();

  TransportPart(const TransportPart& from);

  inline TransportPart& operator=(const TransportPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransportPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransportPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransportPart* other);

  // implements Message ----------------------------------------------

  TransportPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransportPart& from);
  void MergeFrom(const TransportPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 left = 4;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 4;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // optional int32 right = 5;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 5;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // optional int32 top = 6;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 6;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // optional int32 bottom = 7;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 7;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // optional int64 stringTableOffset = 8;
  inline bool has_stringtableoffset() const;
  inline void clear_stringtableoffset();
  static const int kStringTableOffsetFieldNumber = 8;
  inline ::google::protobuf::int64 stringtableoffset() const;
  inline void set_stringtableoffset(::google::protobuf::int64 value);

  // optional int32 stringTableLength = 9;
  inline bool has_stringtablelength() const;
  inline void clear_stringtablelength();
  static const int kStringTableLengthFieldNumber = 9;
  inline ::google::protobuf::int32 stringtablelength() const;
  inline void set_stringtablelength(::google::protobuf::int32 value);

  // optional int64 stopsTableOffset = 10;
  inline bool has_stopstableoffset() const;
  inline void clear_stopstableoffset();
  static const int kStopsTableOffsetFieldNumber = 10;
  inline ::google::protobuf::int64 stopstableoffset() const;
  inline void set_stopstableoffset(::google::protobuf::int64 value);

  // optional int64 stopsTableLength = 11;
  inline bool has_stopstablelength() const;
  inline void clear_stopstablelength();
  static const int kStopsTableLengthFieldNumber = 11;
  inline ::google::protobuf::int64 stopstablelength() const;
  inline void set_stopstablelength(::google::protobuf::int64 value);

  // optional int64 incompleteRoutesOffset = 12;
  inline bool has_incompleteroutesoffset() const;
  inline void clear_incompleteroutesoffset();
  static const int kIncompleteRoutesOffsetFieldNumber = 12;
  inline ::google::protobuf::int64 incompleteroutesoffset() const;
  inline void set_incompleteroutesoffset(::google::protobuf::int64 value);

  // optional int64 incompleteRoutesLength = 13;
  inline bool has_incompleterouteslength() const;
  inline void clear_incompleterouteslength();
  static const int kIncompleteRoutesLengthFieldNumber = 13;
  inline ::google::protobuf::int64 incompleterouteslength() const;
  inline void set_incompleterouteslength(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportPart)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_stringtableoffset();
  inline void clear_has_stringtableoffset();
  inline void set_has_stringtablelength();
  inline void clear_has_stringtablelength();
  inline void set_has_stopstableoffset();
  inline void clear_has_stopstableoffset();
  inline void set_has_stopstablelength();
  inline void clear_has_stopstablelength();
  inline void set_has_incompleteroutesoffset();
  inline void clear_has_incompleteroutesoffset();
  inline void set_has_incompleterouteslength();
  inline void clear_has_incompleterouteslength();

  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 offset_;
  ::std::string* name_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::int64 stringtableoffset_;
  ::google::protobuf::int64 stopstableoffset_;
  ::google::protobuf::int64 stopstablelength_;
  ::google::protobuf::int64 incompleteroutesoffset_;
  ::google::protobuf::int64 incompleterouteslength_;
  ::google::protobuf::int32 stringtablelength_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmand_5findex_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmand_5findex_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmand_5findex_2eproto();
  friend void protobuf_ShutdownFile_osmand_5findex_2eproto();

  void InitAsDefaultInstance();
  static TransportPart* default_instance_;
};
// ===================================================================


// ===================================================================

// OsmAndStoredIndex

// required uint32 version = 1;
inline bool OsmAndStoredIndex::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndStoredIndex::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndStoredIndex::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndStoredIndex::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 OsmAndStoredIndex::version() const {
  return version_;
}
inline void OsmAndStoredIndex::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required int64 dateCreated = 18;
inline bool OsmAndStoredIndex::has_datecreated() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndStoredIndex::set_has_datecreated() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndStoredIndex::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndStoredIndex::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  clear_has_datecreated();
}
inline ::google::protobuf::int64 OsmAndStoredIndex::datecreated() const {
  return datecreated_;
}
inline void OsmAndStoredIndex::set_datecreated(::google::protobuf::int64 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// repeated .OsmAnd.OBF.FileIndex fileIndex = 7;
inline int OsmAndStoredIndex::fileindex_size() const {
  return fileindex_.size();
}
inline void OsmAndStoredIndex::clear_fileindex() {
  fileindex_.Clear();
}
inline const ::OsmAnd::OBF::FileIndex& OsmAndStoredIndex::fileindex(int index) const {
  return fileindex_.Get(index);
}
inline ::OsmAnd::OBF::FileIndex* OsmAndStoredIndex::mutable_fileindex(int index) {
  return fileindex_.Mutable(index);
}
inline ::OsmAnd::OBF::FileIndex* OsmAndStoredIndex::add_fileindex() {
  return fileindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::FileIndex >&
OsmAndStoredIndex::fileindex() const {
  return fileindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::FileIndex >*
OsmAndStoredIndex::mutable_fileindex() {
  return &fileindex_;
}

// -------------------------------------------------------------------

// FileIndex

// required int64 size = 1;
inline bool FileIndex::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileIndex::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileIndex::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileIndex::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 FileIndex::size() const {
  return size_;
}
inline void FileIndex::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 dateModified = 2;
inline bool FileIndex::has_datemodified() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileIndex::set_has_datemodified() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileIndex::clear_has_datemodified() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileIndex::clear_datemodified() {
  datemodified_ = GOOGLE_LONGLONG(0);
  clear_has_datemodified();
}
inline ::google::protobuf::int64 FileIndex::datemodified() const {
  return datemodified_;
}
inline void FileIndex::set_datemodified(::google::protobuf::int64 value) {
  set_has_datemodified();
  datemodified_ = value;
}

// required string fileName = 3;
inline bool FileIndex::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileIndex::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileIndex::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileIndex::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FileIndex::filename() const {
  return *filename_;
}
inline void FileIndex::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FileIndex::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FileIndex::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileIndex::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FileIndex::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileIndex::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 version = 4;
inline bool FileIndex::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileIndex::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileIndex::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileIndex::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 FileIndex::version() const {
  return version_;
}
inline void FileIndex::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// repeated .OsmAnd.OBF.AddressPart addressIndex = 8;
inline int FileIndex::addressindex_size() const {
  return addressindex_.size();
}
inline void FileIndex::clear_addressindex() {
  addressindex_.Clear();
}
inline const ::OsmAnd::OBF::AddressPart& FileIndex::addressindex(int index) const {
  return addressindex_.Get(index);
}
inline ::OsmAnd::OBF::AddressPart* FileIndex::mutable_addressindex(int index) {
  return addressindex_.Mutable(index);
}
inline ::OsmAnd::OBF::AddressPart* FileIndex::add_addressindex() {
  return addressindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressPart >&
FileIndex::addressindex() const {
  return addressindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressPart >*
FileIndex::mutable_addressindex() {
  return &addressindex_;
}

// repeated .OsmAnd.OBF.TransportPart transportIndex = 9;
inline int FileIndex::transportindex_size() const {
  return transportindex_.size();
}
inline void FileIndex::clear_transportindex() {
  transportindex_.Clear();
}
inline const ::OsmAnd::OBF::TransportPart& FileIndex::transportindex(int index) const {
  return transportindex_.Get(index);
}
inline ::OsmAnd::OBF::TransportPart* FileIndex::mutable_transportindex(int index) {
  return transportindex_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportPart* FileIndex::add_transportindex() {
  return transportindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportPart >&
FileIndex::transportindex() const {
  return transportindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportPart >*
FileIndex::mutable_transportindex() {
  return &transportindex_;
}

// repeated .OsmAnd.OBF.PoiPart poiIndex = 10;
inline int FileIndex::poiindex_size() const {
  return poiindex_.size();
}
inline void FileIndex::clear_poiindex() {
  poiindex_.Clear();
}
inline const ::OsmAnd::OBF::PoiPart& FileIndex::poiindex(int index) const {
  return poiindex_.Get(index);
}
inline ::OsmAnd::OBF::PoiPart* FileIndex::mutable_poiindex(int index) {
  return poiindex_.Mutable(index);
}
inline ::OsmAnd::OBF::PoiPart* FileIndex::add_poiindex() {
  return poiindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::PoiPart >&
FileIndex::poiindex() const {
  return poiindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::PoiPart >*
FileIndex::mutable_poiindex() {
  return &poiindex_;
}

// repeated .OsmAnd.OBF.MapPart mapIndex = 11;
inline int FileIndex::mapindex_size() const {
  return mapindex_.size();
}
inline void FileIndex::clear_mapindex() {
  mapindex_.Clear();
}
inline const ::OsmAnd::OBF::MapPart& FileIndex::mapindex(int index) const {
  return mapindex_.Get(index);
}
inline ::OsmAnd::OBF::MapPart* FileIndex::mutable_mapindex(int index) {
  return mapindex_.Mutable(index);
}
inline ::OsmAnd::OBF::MapPart* FileIndex::add_mapindex() {
  return mapindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapPart >&
FileIndex::mapindex() const {
  return mapindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapPart >*
FileIndex::mutable_mapindex() {
  return &mapindex_;
}

// repeated .OsmAnd.OBF.RoutingPart routingIndex = 12;
inline int FileIndex::routingindex_size() const {
  return routingindex_.size();
}
inline void FileIndex::clear_routingindex() {
  routingindex_.Clear();
}
inline const ::OsmAnd::OBF::RoutingPart& FileIndex::routingindex(int index) const {
  return routingindex_.Get(index);
}
inline ::OsmAnd::OBF::RoutingPart* FileIndex::mutable_routingindex(int index) {
  return routingindex_.Mutable(index);
}
inline ::OsmAnd::OBF::RoutingPart* FileIndex::add_routingindex() {
  return routingindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingPart >&
FileIndex::routingindex() const {
  return routingindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingPart >*
FileIndex::mutable_routingindex() {
  return &routingindex_;
}

// repeated .OsmAnd.OBF.HHRoutingPart hhRoutingIndex = 13;
inline int FileIndex::hhroutingindex_size() const {
  return hhroutingindex_.size();
}
inline void FileIndex::clear_hhroutingindex() {
  hhroutingindex_.Clear();
}
inline const ::OsmAnd::OBF::HHRoutingPart& FileIndex::hhroutingindex(int index) const {
  return hhroutingindex_.Get(index);
}
inline ::OsmAnd::OBF::HHRoutingPart* FileIndex::mutable_hhroutingindex(int index) {
  return hhroutingindex_.Mutable(index);
}
inline ::OsmAnd::OBF::HHRoutingPart* FileIndex::add_hhroutingindex() {
  return hhroutingindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::HHRoutingPart >&
FileIndex::hhroutingindex() const {
  return hhroutingindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::HHRoutingPart >*
FileIndex::mutable_hhroutingindex() {
  return &hhroutingindex_;
}

// -------------------------------------------------------------------

// AddressPart

// required int64 size = 1;
inline bool AddressPart::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddressPart::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddressPart::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddressPart::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 AddressPart::size() const {
  return size_;
}
inline void AddressPart::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool AddressPart::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddressPart::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddressPart::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddressPart::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 AddressPart::offset() const {
  return offset_;
}
inline void AddressPart::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional string name = 3;
inline bool AddressPart::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddressPart::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddressPart::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddressPart::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AddressPart::name() const {
  return *name_;
}
inline void AddressPart::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressPart::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressPart::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressPart::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AddressPart::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressPart::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nameEn = 4;
inline bool AddressPart::has_nameen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddressPart::set_has_nameen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddressPart::clear_has_nameen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddressPart::clear_nameen() {
  if (nameen_ != &::google::protobuf::internal::kEmptyString) {
    nameen_->clear();
  }
  clear_has_nameen();
}
inline const ::std::string& AddressPart::nameen() const {
  return *nameen_;
}
inline void AddressPart::set_nameen(const ::std::string& value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressPart::set_nameen(const char* value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressPart::set_nameen(const char* value, size_t size) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressPart::mutable_nameen() {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}
inline ::std::string* AddressPart::release_nameen() {
  clear_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nameen_;
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressPart::set_allocated_nameen(::std::string* nameen) {
  if (nameen_ != &::google::protobuf::internal::kEmptyString) {
    delete nameen_;
  }
  if (nameen) {
    set_has_nameen();
    nameen_ = nameen;
  } else {
    clear_has_nameen();
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 indexNameOffset = 5;
inline bool AddressPart::has_indexnameoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddressPart::set_has_indexnameoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddressPart::clear_has_indexnameoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddressPart::clear_indexnameoffset() {
  indexnameoffset_ = GOOGLE_LONGLONG(0);
  clear_has_indexnameoffset();
}
inline ::google::protobuf::int64 AddressPart::indexnameoffset() const {
  return indexnameoffset_;
}
inline void AddressPart::set_indexnameoffset(::google::protobuf::int64 value) {
  set_has_indexnameoffset();
  indexnameoffset_ = value;
}

// repeated .OsmAnd.OBF.CityBlock cities = 8;
inline int AddressPart::cities_size() const {
  return cities_.size();
}
inline void AddressPart::clear_cities() {
  cities_.Clear();
}
inline const ::OsmAnd::OBF::CityBlock& AddressPart::cities(int index) const {
  return cities_.Get(index);
}
inline ::OsmAnd::OBF::CityBlock* AddressPart::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::OsmAnd::OBF::CityBlock* AddressPart::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlock >&
AddressPart::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlock >*
AddressPart::mutable_cities() {
  return &cities_;
}

// repeated string additionalTags = 9;
inline int AddressPart::additionaltags_size() const {
  return additionaltags_.size();
}
inline void AddressPart::clear_additionaltags() {
  additionaltags_.Clear();
}
inline const ::std::string& AddressPart::additionaltags(int index) const {
  return additionaltags_.Get(index);
}
inline ::std::string* AddressPart::mutable_additionaltags(int index) {
  return additionaltags_.Mutable(index);
}
inline void AddressPart::set_additionaltags(int index, const ::std::string& value) {
  additionaltags_.Mutable(index)->assign(value);
}
inline void AddressPart::set_additionaltags(int index, const char* value) {
  additionaltags_.Mutable(index)->assign(value);
}
inline void AddressPart::set_additionaltags(int index, const char* value, size_t size) {
  additionaltags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressPart::add_additionaltags() {
  return additionaltags_.Add();
}
inline void AddressPart::add_additionaltags(const ::std::string& value) {
  additionaltags_.Add()->assign(value);
}
inline void AddressPart::add_additionaltags(const char* value) {
  additionaltags_.Add()->assign(value);
}
inline void AddressPart::add_additionaltags(const char* value, size_t size) {
  additionaltags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddressPart::additionaltags() const {
  return additionaltags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddressPart::mutable_additionaltags() {
  return &additionaltags_;
}

// -------------------------------------------------------------------

// CityBlock

// required int64 size = 1;
inline bool CityBlock::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CityBlock::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CityBlock::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CityBlock::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 CityBlock::size() const {
  return size_;
}
inline void CityBlock::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool CityBlock::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CityBlock::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CityBlock::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CityBlock::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 CityBlock::offset() const {
  return offset_;
}
inline void CityBlock::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 type = 3;
inline bool CityBlock::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CityBlock::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CityBlock::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CityBlock::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CityBlock::type() const {
  return type_;
}
inline void CityBlock::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PoiPart

// required int64 size = 1;
inline bool PoiPart::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoiPart::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoiPart::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoiPart::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 PoiPart::size() const {
  return size_;
}
inline void PoiPart::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool PoiPart::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoiPart::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoiPart::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoiPart::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 PoiPart::offset() const {
  return offset_;
}
inline void PoiPart::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional string name = 3;
inline bool PoiPart::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoiPart::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoiPart::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoiPart::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PoiPart::name() const {
  return *name_;
}
inline void PoiPart::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PoiPart::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PoiPart::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiPart::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PoiPart::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PoiPart::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 left = 4;
inline bool PoiPart::has_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoiPart::set_has_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoiPart::clear_has_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoiPart::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 PoiPart::left() const {
  return left_;
}
inline void PoiPart::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required int32 right = 5;
inline bool PoiPart::has_right() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoiPart::set_has_right() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoiPart::clear_has_right() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoiPart::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 PoiPart::right() const {
  return right_;
}
inline void PoiPart::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 top = 6;
inline bool PoiPart::has_top() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PoiPart::set_has_top() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PoiPart::clear_has_top() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PoiPart::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 PoiPart::top() const {
  return top_;
}
inline void PoiPart::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required int32 bottom = 7;
inline bool PoiPart::has_bottom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PoiPart::set_has_bottom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PoiPart::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PoiPart::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 PoiPart::bottom() const {
  return bottom_;
}
inline void PoiPart::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// -------------------------------------------------------------------

// MapLevel

// required int64 size = 1;
inline bool MapLevel::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapLevel::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapLevel::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapLevel::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 MapLevel::size() const {
  return size_;
}
inline void MapLevel::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool MapLevel::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapLevel::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapLevel::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapLevel::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 MapLevel::offset() const {
  return offset_;
}
inline void MapLevel::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 left = 4;
inline bool MapLevel::has_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapLevel::set_has_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapLevel::clear_has_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapLevel::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 MapLevel::left() const {
  return left_;
}
inline void MapLevel::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required int32 right = 5;
inline bool MapLevel::has_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapLevel::set_has_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapLevel::clear_has_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapLevel::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 MapLevel::right() const {
  return right_;
}
inline void MapLevel::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 top = 6;
inline bool MapLevel::has_top() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapLevel::set_has_top() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapLevel::clear_has_top() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapLevel::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 MapLevel::top() const {
  return top_;
}
inline void MapLevel::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required int32 bottom = 7;
inline bool MapLevel::has_bottom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapLevel::set_has_bottom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapLevel::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapLevel::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 MapLevel::bottom() const {
  return bottom_;
}
inline void MapLevel::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// optional int32 minzoom = 8;
inline bool MapLevel::has_minzoom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapLevel::set_has_minzoom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapLevel::clear_has_minzoom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapLevel::clear_minzoom() {
  minzoom_ = 0;
  clear_has_minzoom();
}
inline ::google::protobuf::int32 MapLevel::minzoom() const {
  return minzoom_;
}
inline void MapLevel::set_minzoom(::google::protobuf::int32 value) {
  set_has_minzoom();
  minzoom_ = value;
}

// optional int32 maxzoom = 9;
inline bool MapLevel::has_maxzoom() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapLevel::set_has_maxzoom() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapLevel::clear_has_maxzoom() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapLevel::clear_maxzoom() {
  maxzoom_ = 0;
  clear_has_maxzoom();
}
inline ::google::protobuf::int32 MapLevel::maxzoom() const {
  return maxzoom_;
}
inline void MapLevel::set_maxzoom(::google::protobuf::int32 value) {
  set_has_maxzoom();
  maxzoom_ = value;
}

// -------------------------------------------------------------------

// MapPart

// required int64 size = 1;
inline bool MapPart::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPart::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPart::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPart::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 MapPart::size() const {
  return size_;
}
inline void MapPart::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool MapPart::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPart::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPart::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPart::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 MapPart::offset() const {
  return offset_;
}
inline void MapPart::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional string name = 3;
inline bool MapPart::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapPart::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapPart::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapPart::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapPart::name() const {
  return *name_;
}
inline void MapPart::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapPart::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapPart::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapPart::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MapPart::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapPart::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.MapLevel levels = 5;
inline int MapPart::levels_size() const {
  return levels_.size();
}
inline void MapPart::clear_levels() {
  levels_.Clear();
}
inline const ::OsmAnd::OBF::MapLevel& MapPart::levels(int index) const {
  return levels_.Get(index);
}
inline ::OsmAnd::OBF::MapLevel* MapPart::mutable_levels(int index) {
  return levels_.Mutable(index);
}
inline ::OsmAnd::OBF::MapLevel* MapPart::add_levels() {
  return levels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapLevel >&
MapPart::levels() const {
  return levels_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapLevel >*
MapPart::mutable_levels() {
  return &levels_;
}

// -------------------------------------------------------------------

// RoutingSubregion

// required int64 size = 1;
inline bool RoutingSubregion::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingSubregion::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingSubregion::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingSubregion::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 RoutingSubregion::size() const {
  return size_;
}
inline void RoutingSubregion::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool RoutingSubregion::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingSubregion::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingSubregion::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingSubregion::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 RoutingSubregion::offset() const {
  return offset_;
}
inline void RoutingSubregion::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional bool basemap = 3;
inline bool RoutingSubregion::has_basemap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoutingSubregion::set_has_basemap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoutingSubregion::clear_has_basemap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoutingSubregion::clear_basemap() {
  basemap_ = false;
  clear_has_basemap();
}
inline bool RoutingSubregion::basemap() const {
  return basemap_;
}
inline void RoutingSubregion::set_basemap(bool value) {
  set_has_basemap();
  basemap_ = value;
}

// required int32 left = 4;
inline bool RoutingSubregion::has_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoutingSubregion::set_has_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoutingSubregion::clear_has_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoutingSubregion::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 RoutingSubregion::left() const {
  return left_;
}
inline void RoutingSubregion::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required int32 right = 5;
inline bool RoutingSubregion::has_right() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoutingSubregion::set_has_right() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoutingSubregion::clear_has_right() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoutingSubregion::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 RoutingSubregion::right() const {
  return right_;
}
inline void RoutingSubregion::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 top = 6;
inline bool RoutingSubregion::has_top() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoutingSubregion::set_has_top() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoutingSubregion::clear_has_top() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoutingSubregion::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 RoutingSubregion::top() const {
  return top_;
}
inline void RoutingSubregion::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required int32 bottom = 7;
inline bool RoutingSubregion::has_bottom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoutingSubregion::set_has_bottom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoutingSubregion::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoutingSubregion::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 RoutingSubregion::bottom() const {
  return bottom_;
}
inline void RoutingSubregion::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// required int64 shifToData = 8;
inline bool RoutingSubregion::has_shiftodata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoutingSubregion::set_has_shiftodata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoutingSubregion::clear_has_shiftodata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoutingSubregion::clear_shiftodata() {
  shiftodata_ = GOOGLE_LONGLONG(0);
  clear_has_shiftodata();
}
inline ::google::protobuf::int64 RoutingSubregion::shiftodata() const {
  return shiftodata_;
}
inline void RoutingSubregion::set_shiftodata(::google::protobuf::int64 value) {
  set_has_shiftodata();
  shiftodata_ = value;
}

// -------------------------------------------------------------------

// RoutingPart

// required int64 size = 1;
inline bool RoutingPart::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingPart::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingPart::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingPart::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 RoutingPart::size() const {
  return size_;
}
inline void RoutingPart::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool RoutingPart::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingPart::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingPart::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingPart::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 RoutingPart::offset() const {
  return offset_;
}
inline void RoutingPart::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional string name = 3;
inline bool RoutingPart::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoutingPart::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoutingPart::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoutingPart::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoutingPart::name() const {
  return *name_;
}
inline void RoutingPart::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoutingPart::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoutingPart::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutingPart::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoutingPart::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoutingPart::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.RoutingSubregion subregions = 5;
inline int RoutingPart::subregions_size() const {
  return subregions_.size();
}
inline void RoutingPart::clear_subregions() {
  subregions_.Clear();
}
inline const ::OsmAnd::OBF::RoutingSubregion& RoutingPart::subregions(int index) const {
  return subregions_.Get(index);
}
inline ::OsmAnd::OBF::RoutingSubregion* RoutingPart::mutable_subregions(int index) {
  return subregions_.Mutable(index);
}
inline ::OsmAnd::OBF::RoutingSubregion* RoutingPart::add_subregions() {
  return subregions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingSubregion >&
RoutingPart::subregions() const {
  return subregions_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RoutingSubregion >*
RoutingPart::mutable_subregions() {
  return &subregions_;
}

// -------------------------------------------------------------------

// HHRoutingPart

// required int64 size = 1;
inline bool HHRoutingPart::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HHRoutingPart::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HHRoutingPart::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HHRoutingPart::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 HHRoutingPart::size() const {
  return size_;
}
inline void HHRoutingPart::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool HHRoutingPart::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HHRoutingPart::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HHRoutingPart::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HHRoutingPart::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 HHRoutingPart::offset() const {
  return offset_;
}
inline void HHRoutingPart::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// required int64 edition = 3;
inline bool HHRoutingPart::has_edition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HHRoutingPart::set_has_edition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HHRoutingPart::clear_has_edition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HHRoutingPart::clear_edition() {
  edition_ = GOOGLE_LONGLONG(0);
  clear_has_edition();
}
inline ::google::protobuf::int64 HHRoutingPart::edition() const {
  return edition_;
}
inline void HHRoutingPart::set_edition(::google::protobuf::int64 value) {
  set_has_edition();
  edition_ = value;
}

// required string profile = 4;
inline bool HHRoutingPart::has_profile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HHRoutingPart::set_has_profile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HHRoutingPart::clear_has_profile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HHRoutingPart::clear_profile() {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    profile_->clear();
  }
  clear_has_profile();
}
inline const ::std::string& HHRoutingPart::profile() const {
  return *profile_;
}
inline void HHRoutingPart::set_profile(const ::std::string& value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void HHRoutingPart::set_profile(const char* value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void HHRoutingPart::set_profile(const char* value, size_t size) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HHRoutingPart::mutable_profile() {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  return profile_;
}
inline ::std::string* HHRoutingPart::release_profile() {
  clear_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profile_;
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HHRoutingPart::set_allocated_profile(::std::string* profile) {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    delete profile_;
  }
  if (profile) {
    set_has_profile();
    profile_ = profile;
  } else {
    clear_has_profile();
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string profileParams = 5;
inline int HHRoutingPart::profileparams_size() const {
  return profileparams_.size();
}
inline void HHRoutingPart::clear_profileparams() {
  profileparams_.Clear();
}
inline const ::std::string& HHRoutingPart::profileparams(int index) const {
  return profileparams_.Get(index);
}
inline ::std::string* HHRoutingPart::mutable_profileparams(int index) {
  return profileparams_.Mutable(index);
}
inline void HHRoutingPart::set_profileparams(int index, const ::std::string& value) {
  profileparams_.Mutable(index)->assign(value);
}
inline void HHRoutingPart::set_profileparams(int index, const char* value) {
  profileparams_.Mutable(index)->assign(value);
}
inline void HHRoutingPart::set_profileparams(int index, const char* value, size_t size) {
  profileparams_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HHRoutingPart::add_profileparams() {
  return profileparams_.Add();
}
inline void HHRoutingPart::add_profileparams(const ::std::string& value) {
  profileparams_.Add()->assign(value);
}
inline void HHRoutingPart::add_profileparams(const char* value) {
  profileparams_.Add()->assign(value);
}
inline void HHRoutingPart::add_profileparams(const char* value, size_t size) {
  profileparams_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HHRoutingPart::profileparams() const {
  return profileparams_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HHRoutingPart::mutable_profileparams() {
  return &profileparams_;
}

// required int64 pointsOffset = 7;
inline bool HHRoutingPart::has_pointsoffset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HHRoutingPart::set_has_pointsoffset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HHRoutingPart::clear_has_pointsoffset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HHRoutingPart::clear_pointsoffset() {
  pointsoffset_ = GOOGLE_LONGLONG(0);
  clear_has_pointsoffset();
}
inline ::google::protobuf::int64 HHRoutingPart::pointsoffset() const {
  return pointsoffset_;
}
inline void HHRoutingPart::set_pointsoffset(::google::protobuf::int64 value) {
  set_has_pointsoffset();
  pointsoffset_ = value;
}

// required int64 pointsLength = 8;
inline bool HHRoutingPart::has_pointslength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HHRoutingPart::set_has_pointslength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HHRoutingPart::clear_has_pointslength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HHRoutingPart::clear_pointslength() {
  pointslength_ = GOOGLE_LONGLONG(0);
  clear_has_pointslength();
}
inline ::google::protobuf::int64 HHRoutingPart::pointslength() const {
  return pointslength_;
}
inline void HHRoutingPart::set_pointslength(::google::protobuf::int64 value) {
  set_has_pointslength();
  pointslength_ = value;
}

// required int32 left = 9;
inline bool HHRoutingPart::has_left() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HHRoutingPart::set_has_left() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HHRoutingPart::clear_has_left() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HHRoutingPart::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 HHRoutingPart::left() const {
  return left_;
}
inline void HHRoutingPart::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required int32 right = 10;
inline bool HHRoutingPart::has_right() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HHRoutingPart::set_has_right() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HHRoutingPart::clear_has_right() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HHRoutingPart::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 HHRoutingPart::right() const {
  return right_;
}
inline void HHRoutingPart::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 top = 11;
inline bool HHRoutingPart::has_top() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HHRoutingPart::set_has_top() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HHRoutingPart::clear_has_top() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HHRoutingPart::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 HHRoutingPart::top() const {
  return top_;
}
inline void HHRoutingPart::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required int32 bottom = 12;
inline bool HHRoutingPart::has_bottom() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HHRoutingPart::set_has_bottom() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HHRoutingPart::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HHRoutingPart::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 HHRoutingPart::bottom() const {
  return bottom_;
}
inline void HHRoutingPart::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// -------------------------------------------------------------------

// TransportPart

// required int64 size = 1;
inline bool TransportPart::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportPart::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportPart::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportPart::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 TransportPart::size() const {
  return size_;
}
inline void TransportPart::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 offset = 2;
inline bool TransportPart::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportPart::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportPart::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportPart::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 TransportPart::offset() const {
  return offset_;
}
inline void TransportPart::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional string name = 3;
inline bool TransportPart::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportPart::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportPart::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportPart::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TransportPart::name() const {
  return *name_;
}
inline void TransportPart::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransportPart::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransportPart::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportPart::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TransportPart::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportPart::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 left = 4;
inline bool TransportPart::has_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportPart::set_has_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportPart::clear_has_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportPart::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 TransportPart::left() const {
  return left_;
}
inline void TransportPart::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// optional int32 right = 5;
inline bool TransportPart::has_right() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransportPart::set_has_right() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransportPart::clear_has_right() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransportPart::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 TransportPart::right() const {
  return right_;
}
inline void TransportPart::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// optional int32 top = 6;
inline bool TransportPart::has_top() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransportPart::set_has_top() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransportPart::clear_has_top() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransportPart::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 TransportPart::top() const {
  return top_;
}
inline void TransportPart::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// optional int32 bottom = 7;
inline bool TransportPart::has_bottom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransportPart::set_has_bottom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransportPart::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransportPart::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 TransportPart::bottom() const {
  return bottom_;
}
inline void TransportPart::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// optional int64 stringTableOffset = 8;
inline bool TransportPart::has_stringtableoffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransportPart::set_has_stringtableoffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransportPart::clear_has_stringtableoffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransportPart::clear_stringtableoffset() {
  stringtableoffset_ = GOOGLE_LONGLONG(0);
  clear_has_stringtableoffset();
}
inline ::google::protobuf::int64 TransportPart::stringtableoffset() const {
  return stringtableoffset_;
}
inline void TransportPart::set_stringtableoffset(::google::protobuf::int64 value) {
  set_has_stringtableoffset();
  stringtableoffset_ = value;
}

// optional int32 stringTableLength = 9;
inline bool TransportPart::has_stringtablelength() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransportPart::set_has_stringtablelength() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransportPart::clear_has_stringtablelength() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransportPart::clear_stringtablelength() {
  stringtablelength_ = 0;
  clear_has_stringtablelength();
}
inline ::google::protobuf::int32 TransportPart::stringtablelength() const {
  return stringtablelength_;
}
inline void TransportPart::set_stringtablelength(::google::protobuf::int32 value) {
  set_has_stringtablelength();
  stringtablelength_ = value;
}

// optional int64 stopsTableOffset = 10;
inline bool TransportPart::has_stopstableoffset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TransportPart::set_has_stopstableoffset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TransportPart::clear_has_stopstableoffset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TransportPart::clear_stopstableoffset() {
  stopstableoffset_ = GOOGLE_LONGLONG(0);
  clear_has_stopstableoffset();
}
inline ::google::protobuf::int64 TransportPart::stopstableoffset() const {
  return stopstableoffset_;
}
inline void TransportPart::set_stopstableoffset(::google::protobuf::int64 value) {
  set_has_stopstableoffset();
  stopstableoffset_ = value;
}

// optional int64 stopsTableLength = 11;
inline bool TransportPart::has_stopstablelength() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TransportPart::set_has_stopstablelength() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TransportPart::clear_has_stopstablelength() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TransportPart::clear_stopstablelength() {
  stopstablelength_ = GOOGLE_LONGLONG(0);
  clear_has_stopstablelength();
}
inline ::google::protobuf::int64 TransportPart::stopstablelength() const {
  return stopstablelength_;
}
inline void TransportPart::set_stopstablelength(::google::protobuf::int64 value) {
  set_has_stopstablelength();
  stopstablelength_ = value;
}

// optional int64 incompleteRoutesOffset = 12;
inline bool TransportPart::has_incompleteroutesoffset() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TransportPart::set_has_incompleteroutesoffset() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TransportPart::clear_has_incompleteroutesoffset() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TransportPart::clear_incompleteroutesoffset() {
  incompleteroutesoffset_ = GOOGLE_LONGLONG(0);
  clear_has_incompleteroutesoffset();
}
inline ::google::protobuf::int64 TransportPart::incompleteroutesoffset() const {
  return incompleteroutesoffset_;
}
inline void TransportPart::set_incompleteroutesoffset(::google::protobuf::int64 value) {
  set_has_incompleteroutesoffset();
  incompleteroutesoffset_ = value;
}

// optional int64 incompleteRoutesLength = 13;
inline bool TransportPart::has_incompleterouteslength() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TransportPart::set_has_incompleterouteslength() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TransportPart::clear_has_incompleterouteslength() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TransportPart::clear_incompleterouteslength() {
  incompleterouteslength_ = GOOGLE_LONGLONG(0);
  clear_has_incompleterouteslength();
}
inline ::google::protobuf::int64 TransportPart::incompleterouteslength() const {
  return incompleterouteslength_;
}
inline void TransportPart::set_incompleterouteslength(::google::protobuf::int64 value) {
  set_has_incompleterouteslength();
  incompleterouteslength_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OBF
}  // namespace OsmAnd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_osmand_5findex_2eproto__INCLUDED
